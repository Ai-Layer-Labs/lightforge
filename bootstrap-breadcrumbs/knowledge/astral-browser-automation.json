{
  "schema_name": "knowledge.v1",
  "title": "Complete Guide: Astral Browser Automation Tool Creation",
  "tags": [
    "knowledge",
    "browser-automation",
    "astral",
    "tool-creation",
    "workspace:system"
  ],
  "context": {
    "topic": "astral-browser-automation",
    "audience": "LLM agents creating browser automation tools",
    "last_updated": "2025-11-10",
    "content": {
      "summary": "Comprehensive guide for creating browser automation tools using the Astral library (jsr:@astral/astral). Astral is a high-level Puppeteer/Playwright-like library for Deno that enables headless browser control, web scraping, testing, and automation.",
      
      "astral_overview": {
        "description": "Astral is a browser automation library built specifically for Deno",
        "source": "https://github.com/lino-levan/astral",
        "jsr_package": "jsr:@astral/astral",
        "capabilities": [
          "Launch headless or visible browsers",
          "Navigate to URLs with wait conditions",
          "Take screenshots (PNG/JPEG)",
          "Click elements using CSS selectors",
          "Type text into input fields with delays",
          "Evaluate JavaScript in page context",
          "Wait for selectors, navigation, network idle, or time",
          "Extract page content (HTML, text, links, headings)",
          "Multi-page support",
          "Connect to remote browsers or reuse existing instances"
        ],
        "key_features": {
          "headless_mode": "Run browsers invisibly for automation",
          "page_evaluation": "Execute JavaScript in browser context",
          "selector_api": "Find and interact with DOM elements",
          "network_control": "Wait for network idle, handle navigation",
          "state_management": "Manage multiple browsers and pages simultaneously"
        }
      },
      
      "basic_usage_pattern": {
        "description": "Standard Astral usage pattern (from official docs)",
        "example_code": "import { launch } from 'jsr:@astral/astral';\n\n// Launch browser\nawait using browser = await launch();\n\n// Open page\nawait using page = await browser.newPage('https://example.com');\n\n// Interact\nconst button = await page.$('button');\nawait button!.click();\n\n// Screenshot\nconst screenshot = await page.screenshot();\n\n// Evaluate JS\nconst value = await page.evaluate(() => document.title);",
        "key_concepts": [
          "await using - Automatic cleanup with disposable pattern",
          "browser.newPage() - Create new page instance",
          "page.$() - Find element by CSS selector",
          "page.evaluate() - Run code in browser context",
          "page.screenshot() - Capture visual state"
        ]
      },
      
      "rcrt_tool_structure": {
        "description": "How to structure Astral as a tool.code.v1 breadcrumb",
        "critical_requirements": [
          "Import: import { launch, connect } from 'jsr:@astral/astral'",
          "Export: export async function execute(input, context)",
          "State management: Use Map<string, Browser> and Map<string, Page>",
          "ID generation: Create browser_id and page_id for multi-operation workflows",
          "Action-based: Support multiple actions (launch, navigate, screenshot, etc.)",
          "Error handling: Try/catch with descriptive error messages"
        ],
        "permissions_needed": {
          "net": true,
          "read": true,
          "write": true,
          "run": true,
          "env": true,
          "ffi": false,
          "hrtime": true
        },
        "permission_explanations": {
          "net": "Required for browser to make network requests",
          "read": "Required for reading browser binaries and cache",
          "write": "Required for temporary files and cache",
          "run": "Required to spawn browser process",
          "env": "Required for XDG_CACHE_HOME and other browser environment variables",
          "hrtime": "Required for accurate timing and performance metrics"
        },
        "validation_note": "See tool-validation-rules.json for complete validation checklist and permission requirements"
      },
      
      "complete_working_example": {
        "description": "Full tool.code.v1 definition for Astral browser automation",
        "structure": {
          "schema_name": "tool.code.v1",
          "title": "Astral Browser Automation (Self-Contained)",
          "tags": ["tool", "tool:astral", "workspace:tools", "self-contained", "browser", "automation"],
          "context": {
            "name": "astral",
            "description": "High-level browser automation using Astral (Puppeteer/Playwright-like for Deno). Launch browsers, navigate, interact with elements, take screenshots, and extract content.",
            "version": "1.0.0",
            "code": {
              "language": "typescript",
              "source_structure": "See detailed implementation below"
            },
            "input_schema": {
              "type": "object",
              "properties": {
                "action": {
                  "enum": ["launch", "navigate", "screenshot", "click", "type", "evaluate", "get_content", "wait_for", "close"]
                },
                "url": "URL for navigate or initial launch",
                "selector": "CSS selector for click/type/wait",
                "text": "Text to type",
                "script": "JavaScript to evaluate",
                "browser_id": "Browser instance ID",
                "page_id": "Page instance ID"
              },
              "required": ["action"]
            },
            "output_schema": {
              "properties": {
                "success": "boolean",
                "browser_id": "string (for state management)",
                "page_id": "string (for state management)",
                "screenshot": "base64 string",
                "content": "object with page data",
                "value": "evaluation result"
              }
            },
            "permissions": {
              "net": true,
              "read": true,
              "write": true,
              "run": true,
              "hrtime": true
            },
            "limits": {
              "timeout_ms": 120000,
              "memory_mb": 512,
              "cpu_percent": 50
            }
          }
        }
      },
      
      "implementation_guide": {
        "state_management": {
          "description": "Astral tools must maintain browser/page state across tool calls",
          "pattern": "const browsers = new Map<string, Browser>();\nconst pages = new Map<string, Page>();",
          "workflow": [
            "1. Launch: Create browser, store with generated ID, return browser_id and page_id",
            "2. Subsequent actions: Retrieve browser/page by ID from Maps",
            "3. Close: Remove from Maps and close browser"
          ],
          "id_generation": "function generateId() { return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`; }"
        },
        
        "action_handlers": {
          "launch": {
            "purpose": "Start new browser instance",
            "input": {"headless": "boolean", "url": "string (optional)"},
            "output": {"browser_id": "string", "page_id": "string", "url": "string"},
            "code_pattern": "const browser = await launch({ headless: true });\nconst page = await browser.newPage(url);\nconst browserId = generateId();\nconst pageId = generateId();\nbrowsers.set(browserId, browser);\npages.set(pageId, page);\nreturn { browser_id: browserId, page_id: pageId };"
          },
          
          "navigate": {
            "purpose": "Navigate to URL",
            "input": {"page_id": "string", "url": "string", "wait_until": "networkidle2"},
            "output": {"success": "boolean", "url": "string"},
            "code_pattern": "const page = pages.get(input.page_id);\nawait page.goto(input.url, { waitUntil: 'networkidle2' });"
          },
          
          "screenshot": {
            "purpose": "Capture page screenshot",
            "input": {"page_id": "string"},
            "output": {"screenshot": "base64 string"},
            "code_pattern": "const screenshot = await page.screenshot();\nconst base64 = btoa(String.fromCharCode(...screenshot));\nreturn { screenshot: base64 };"
          },
          
          "click": {
            "purpose": "Click element",
            "input": {"page_id": "string", "selector": "string"},
            "code_pattern": "const element = await page.$(selector);\nif (!element) throw new Error('Element not found');\nawait element.click();"
          },
          
          "type": {
            "purpose": "Type text into element",
            "input": {"page_id": "string", "selector": "string", "text": "string", "delay": "number"},
            "code_pattern": "const element = await page.$(selector);\nawait element.type(text, { delay: delay || 100 });"
          },
          
          "evaluate": {
            "purpose": "Run JavaScript in page",
            "input": {"page_id": "string", "script": "string", "args": "array"},
            "output": {"value": "any"},
            "code_pattern": "const func = new Function(...argsNames, `return (${script})`);\nconst value = await page.evaluate(func, { args });"
          },
          
          "get_content": {
            "purpose": "Extract page content",
            "output": {"title": "string", "text": "string", "links": "array", "headings": "array"},
            "code_pattern": "const content = await page.evaluate(() => ({\n  title: document.title,\n  text: document.body.innerText,\n  links: Array.from(document.querySelectorAll('a')).map(a => ({text: a.textContent, href: a.href})),\n  headings: Array.from(document.querySelectorAll('h1,h2,h3')).map(h => ({level: h.tagName, text: h.textContent}))\n}));"
          },
          
          "wait_for": {
            "purpose": "Wait for condition",
            "types": ["selector", "navigation", "networkidle", "time"],
            "code_patterns": {
              "selector": "await page.waitForSelector(selector, { timeout });",
              "navigation": "await page.waitForNavigation({ timeout });",
              "networkidle": "await page.waitForNetworkIdle({ idleTime: ms });",
              "time": "await new Promise(resolve => setTimeout(resolve, ms));"
            }
          }
        }
      },
      
      "multi_step_automation_example": {
        "description": "Example workflow: Search and extract results",
        "steps": [
          {
            "step": 1,
            "action": "launch",
            "input": {"url": "https://deno.land", "headless": true},
            "output": {"browser_id": "abc123", "page_id": "def456"}
          },
          {
            "step": 2,
            "action": "click",
            "input": {"page_id": "def456", "selector": "button.search"},
            "note": "Opens search dialog"
          },
          {
            "step": 3,
            "action": "type",
            "input": {"page_id": "def456", "selector": "#search-input", "text": "astral"},
            "note": "Types search query"
          },
          {
            "step": 4,
            "action": "wait_for",
            "input": {"page_id": "def456", "wait_type": "networkidle"},
            "note": "Wait for results to load"
          },
          {
            "step": 5,
            "action": "get_content",
            "input": {"page_id": "def456"},
            "output": {"title": "Search Results", "text": "...", "links": []}
          },
          {
            "step": 6,
            "action": "screenshot",
            "input": {"page_id": "def456"},
            "output": {"screenshot": "base64..."}
          },
          {
            "step": 7,
            "action": "close",
            "input": {"browser_id": "abc123"}
          }
        ],
        "orchestration_note": "Use workflow tool or agent to chain these actions together"
      },
      
      "best_practices": [
        "Always store browser_id and page_id from launch response for subsequent actions",
        "Use headless: true for production automation (faster, less resources)",
        "Use headless: false for debugging (see what the browser is doing)",
        "Wait for network idle after navigation before interaction",
        "Use specific selectors (IDs or unique classes) for reliability",
        "Add delays when typing to appear more human-like",
        "Always close browsers when done to free resources",
        "Handle element not found errors gracefully",
        "Use wait_for selector before clicking dynamic content",
        "Limit screenshot size by selecting specific elements if possible"
      ],
      
      "common_patterns": {
        "scraping": {
          "description": "Extract content from web pages",
          "actions": ["launch", "navigate", "wait_for (networkidle)", "get_content", "close"],
          "example": "1. Launch browser → 2. Navigate to target → 3. Wait for load → 4. Extract content → 5. Close"
        },
        
        "form_submission": {
          "description": "Fill and submit web forms",
          "actions": ["launch", "navigate", "type (multiple fields)", "click (submit)", "wait_for (navigation)", "close"],
          "example": "1. Navigate to form → 2. Type into each field → 3. Click submit → 4. Wait for success page"
        },
        
        "testing": {
          "description": "Automated UI testing",
          "actions": ["launch", "navigate", "click", "evaluate (assertions)", "screenshot", "close"],
          "example": "1. Navigate to app → 2. Perform actions → 3. Evaluate page state → 4. Screenshot evidence"
        },
        
        "monitoring": {
          "description": "Periodic website checks",
          "actions": ["launch", "navigate", "evaluate (check conditions)", "screenshot (if error)", "close"],
          "use_case": "Check if website is up, elements are present, or content has changed"
        }
      },
      
      "integration_with_rcrt": {
        "context_api_usage": {
          "create_breadcrumb": "Store results: await context.api.createBreadcrumb({ schema_name: 'browser.result.v1', context: {...} })",
          "search_breadcrumbs": "Find targets: const targets = await context.api.searchBreadcrumbs({ tag: 'scraping-target' })",
          "get_secret": "API keys: const apiKey = await context.api.getSecret(secretId, 'reason')"
        },
        
        "workflow_orchestration": {
          "description": "Use workflow tool to chain multiple Astral actions",
          "example": {
            "tool": "workflow",
            "input": {
              "steps": [
                {"id": "start", "tool": "astral", "input": {"action": "launch", "url": "https://example.com"}},
                {"id": "click_btn", "tool": "astral", "input": {"action": "click", "selector": "button", "page_id": "${start.page_id}"}},
                {"id": "screenshot", "tool": "astral", "input": {"action": "screenshot", "page_id": "${start.page_id}"}},
                {"id": "cleanup", "tool": "astral", "input": {"action": "close", "browser_id": "${start.browser_id}"}}
              ]
            }
          },
          "note": "Workflow tool handles variable interpolation (${stepId.field})"
        },
        
        "agent_orchestration": {
          "description": "Agents can create multiple tool requests",
          "pattern": "Agent creates 3 tool.request.v1 breadcrumbs: launch → interact → close",
          "benefit": "Fire-and-forget pattern, agent doesn't wait for each step"
        }
      },
      
      "complete_tool_code_example": {
        "description": "Full implementation ready for tool.code.v1",
        "typescript_code": "import { launch, connect, Browser, Page } from 'jsr:@astral/astral';\n\ninterface Input {\n  action: 'launch' | 'navigate' | 'screenshot' | 'click' | 'type' | 'evaluate' | 'get_content' | 'wait_for' | 'close';\n  headless?: boolean;\n  endpoint?: string;\n  url?: string;\n  wait_until?: 'load' | 'domcontentloaded' | 'networkidle' | 'networkidle2';\n  selector?: string;\n  text?: string;\n  delay?: number;\n  script?: string;\n  args?: any[];\n  wait_type?: 'selector' | 'navigation' | 'networkidle' | 'time';\n  timeout?: number;\n  milliseconds?: number;\n  browser_id?: string;\n  page_id?: string;\n}\n\ninterface Output {\n  success: boolean;\n  action: string;\n  browser_id?: string;\n  page_id?: string;\n  url?: string;\n  screenshot?: string;\n  content?: any;\n  value?: any;\n  error?: string;\n  message?: string;\n}\n\nconst browsers = new Map<string, Browser>();\nconst pages = new Map<string, Page>();\n\nfunction generateId(): string {\n  return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n}\n\nexport async function execute(input: Input, context: any): Promise<Output> {\n  try {\n    switch (input.action) {\n      case 'launch': return await launchBrowser(input);\n      case 'navigate': return await navigateToPage(input);\n      case 'screenshot': return await takeScreenshot(input);\n      case 'click': return await clickElement(input);\n      case 'type': return await typeText(input);\n      case 'evaluate': return await evaluateScript(input);\n      case 'get_content': return await getPageContent(input);\n      case 'wait_for': return await waitFor(input);\n      case 'close': return await closeBrowser(input);\n      default: throw new Error(`Unknown action: ${input.action}`);\n    }\n  } catch (error: any) {\n    return { success: false, action: input.action, error: error.message };\n  }\n}\n\nasync function launchBrowser(input: Input): Promise<Output> {\n  const browserId = generateId();\n  const browser = input.endpoint \n    ? await connect({ endpoint: input.endpoint })\n    : await launch({ headless: input.headless !== false });\n  browsers.set(browserId, browser);\n  const page = await browser.newPage(input.url || 'about:blank');\n  const pageId = generateId();\n  pages.set(pageId, page);\n  return { success: true, action: 'launch', browser_id: browserId, page_id: pageId, url: input.url || 'about:blank' };\n}\n\nasync function getPage(input: Input): Promise<Page> {\n  if (input.page_id) {\n    const page = pages.get(input.page_id);\n    if (!page) throw new Error(`Page not found: ${input.page_id}`);\n    return page;\n  }\n  const pagesArray = Array.from(pages.values());\n  if (pagesArray.length === 0) throw new Error('No pages available. Use action=launch first.');\n  return pagesArray[pagesArray.length - 1];\n}\n\n// See full implementation in complete example",
        "notes": [
          "Import from jsr:@astral/astral at the top",
          "Use TypeScript interfaces for type safety",
          "Maintain global Maps for state",
          "Generate unique IDs for browser/page instances",
          "Handle errors gracefully with try/catch",
          "Return structured output matching output_schema"
        ]
      },
      
      "testing_and_validation": {
        "unit_test": {
          "description": "Test each action independently",
          "test_launch": {"tool": "astral", "input": {"action": "launch", "url": "https://example.com"}},
          "test_screenshot": {"tool": "astral", "input": {"action": "screenshot", "page_id": "from-launch-response"}},
          "verify": "Check tool.response.v1 has success: true and expected fields"
        },
        
        "integration_test": {
          "description": "Test multi-step workflow",
          "use_workflow_tool": true,
          "steps": "launch → navigate → interact → screenshot → close",
          "validation": "All steps return success, final screenshot exists"
        }
      },
      
      "common_mistakes": [
        {
          "mistake": "Not storing browser_id/page_id from launch response",
          "why": "Subsequent actions won't find the browser/page",
          "solution": "Always save IDs from launch and pass to later actions"
        },
        {
          "mistake": "Forgetting run: true permission",
          "why": "Deno can't spawn browser process without --allow-run",
          "solution": "Set permissions.run = true in tool definition"
        },
        {
          "mistake": "Not waiting for network idle",
          "why": "Page might not be fully loaded, selectors won't be found",
          "solution": "Use wait_until: 'networkidle2' or wait_for action before interaction"
        },
        {
          "mistake": "Using wrong selector",
          "why": "Elements not found, clicks fail",
          "solution": "Use page.evaluate() to log available selectors first, use specific IDs"
        },
        {
          "mistake": "Not closing browsers",
          "why": "Memory leak, browser processes accumulate",
          "solution": "Always end automation workflows with close action"
        },
        {
          "mistake": "Timeout too short for slow pages",
          "why": "Tool fails before page loads",
          "solution": "Set timeout_ms: 120000 in limits, use generous timeouts"
        }
      ],
      
      "advanced_features": {
        "remote_browsers": {
          "description": "Connect to browserless.io or other remote browser services",
          "pattern": {"action": "launch", "endpoint": "wss://remote-endpoint.com"},
          "use_case": "Cloud automation, serverless environments"
        },
        
        "authentication": {
          "description": "HTTP basic auth for protected pages",
          "method": "await page.authenticate({ username, password })",
          "note": "Implement as separate action or in navigate action"
        },
        
        "multiple_pages": {
          "description": "Work with multiple tabs/pages",
          "pattern": "Store multiple page_ids, pass correct ID to each action",
          "use_case": "Compare pages, parallel scraping"
        },
        
        "continuous_monitoring": {
          "description": "Long-running browser automation",
          "bootstrap_mode": "continuous",
          "pattern": "Launch browser once, periodically check pages, create result breadcrumbs",
          "use_case": "Website monitoring, price tracking, content change detection"
        }
      },
      
      "quick_reference": {
        "import_statement": "import { launch, connect, Browser, Page } from 'jsr:@astral/astral';",
        "state_management": "const browsers = new Map(); const pages = new Map();",
        "launch_browser": "const browser = await launch({ headless: true });",
        "open_page": "const page = await browser.newPage(url);",
        "find_element": "const el = await page.$(selector);",
        "click": "await el.click();",
        "type": "await el.type(text, { delay: 100 });",
        "screenshot": "const img = await page.screenshot();",
        "evaluate": "const val = await page.evaluate(() => code);",
        "wait": "await page.waitForSelector(selector);",
        "close": "await browser.close();"
      },
      
      "quick_reference_checklist": [
        "☐ Import from jsr:@astral/astral",
        "☐ Implement action handlers (launch, navigate, screenshot, click, type, evaluate, etc.)",
        "☐ State management with Maps for browsers/pages",
        "☐ Permissions: net, read, write, run, env, hrtime (see tool-validation-rules.json)",
        "☐ Comprehensive examples for each action"
      ]
    }
  },
  "semantic_version": "1.0.0",
  "llm_hints": {
    "transform": {
      "formatted": {
        "type": "template",
        "template": "# {{title}}\n\n## Summary\n{{context.content.summary}}\n\n## Astral Overview\n{{#each context.content.astral_overview.capabilities}}• {{this}}\n{{/each}}\n\n## Key Concepts\n{{#each context.content.basic_usage_pattern.key_concepts}}• {{this}}\n{{/each}}\n\n## RCRT Tool Structure Requirements\n{{#each context.content.rcrt_tool_structure.critical_requirements}}• {{this}}\n{{/each}}\n\n## Required Permissions\n```json\n{\n  \"net\": true,\n  \"read\": true,\n  \"write\": true,\n  \"run\": true,\n  \"hrtime\": true\n}\n```\n\nWhy: {{#each context.content.rcrt_tool_structure.permission_explanations}}{{@key}} = {{this}}\n{{/each}}\n\n## Action Handlers\n{{#each context.content.implementation_guide.action_handlers}}\n### {{@key}}\nPurpose: {{this.purpose}}\nInput: {{this.input}}\nOutput: {{this.output}}\n{{#if this.code_pattern}}Code: {{this.code_pattern}}{{/if}}\n{{/each}}\n\n## State Management Pattern\n{{context.content.implementation_guide.state_management.pattern}}\n\nWorkflow:\n{{#each context.content.implementation_guide.state_management.workflow}}{{this}}\n{{/each}}\n\n## Multi-Step Example (7 steps)\n{{#each context.content.multi_step_automation_example.steps}}{{this.step}}. {{this.action}} - {{this.note}}\n{{/each}}\n\n## Best Practices\n{{#each context.content.best_practices}}• {{this}}\n{{/each}}\n\n## Common Mistakes to Avoid\n{{#each context.content.common_mistakes}}• {{this.mistake}}: {{this.solution}}\n{{/each}}\n\n## Quick Reference\n```typescript\n{{#each context.content.quick_reference}}{{@key}}: {{this}}\n{{/each}}\n```"
      }
    },
    "mode": "replace"
  }
}

